\section{Software Architecture}
This chapter describes the architecture of the software developed. First there will be a description of the big picture of the software, which shows the separation the into different parts. Each of these parts will then be explained in greater detail in a separate chapter.

The software architecture has to fulfil multiple requirements for this project. It should be easily extendable with new algorithms and \acrshort{acro:UI} extensions. The input and output format of the application should be independent from the algorithms to support different file types like bitmap images or \gls{gloss:DXF}/\gls{gloss:DWG} formats. The algorithms of the application should be linked together as workflows which then can be executed by an engine simultaneously.

The idea behind this separation concept is that it should be possible to create new combinations of algorithm pipelines with already implemented algorithms. Every algorithm is just a blackbox which can be connected together with other algorithms to create a processing pipeline, called workflow. This makes it possible to replace existing algorithms and test out new ideas without modifying other parts of the pipeline. 

\begin{figure}[h]
  \centering
      \includegraphics[width=1\textwidth]{AFPARS_Architecture}
  \caption{AFPARS software architecture.}
  \label{fig:AFPARS_Architecture}
\end{figure}


To fulfil these requirements, the architecture of the software is split into four parts as shown in Figure \ref{fig:AFPARS_Architecture}. The complete application is based on the \acrfull{acro:JVM} where \gls{gloss:Kotlin} is running on. For image processing and recognition the application uses the library \gls{gloss:OpenCV}.

Every part of the architecture has its own area of responsibility and is connected with the other parts through interfaces which have been designed to be as generic as possible to support the most flexibility.

\subsection{Programming Language}

The software is built with the modern language \gls{gloss:Kotlin}, which is a statically typed programming language for the \acrfull{acro:JVM}. It supports special language features like extension methods, optional parameters and functional programming concepts, which all were used in this project and help to make the code more readable and maintainable. \cite{kotlin}

\subsubsection{Extension Methods}
This section shows an example how the new language is used in the software.

The language feature \flqq Extension Methods\frqq  can be used to make the code more readable. It extends an existing object with a new method without the concept of inheritance. The code of the method will be outsourced into a separate file.

\begin{lstlisting}[caption={Erode image without extension methods},label={lst:imageOperations},language=Java]
// threshold image
Imgproc.threshold(image, image, 128.0, 255.0, 
		Imgproc.THRESH_BINARY)

// erode image
val structureSize = 3
val element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, 
        Size(structureSize.toDouble(), structureSize.toDouble()))
Imgproc.erode(image, image, element)
\end{lstlisting}

It is used in this software to make calls to \gls{gloss:OpenCV} more natural for object oriented developers. For example instead of using the static Imgproc class (see Listing \ref{lst:imageOperations}), it is possible to call a lot of methods on the Mat object itself (see Listing \ref{lst:imageOperationsWithExtensions}).

\begin{lstlisting}[caption={Erode image with extension methods},label={lst:imageOperationsWithExtensions},language=Java]
// threshold image
image.threshold(128.0, 255.0, Imgproc.THRESH_BINARY)

// erode image
image.erode(3)
\end{lstlisting}

\pagebreak

\subsection{Meta Format}
To support the different input and output formats the architecture uses a meta format for the
floor plan images called AFImage. Different \gls{gloss:Drivers} \todo{Define drivers in the glossary} add the support for multiple file formats. With this architecture it is possible to extend the software with new file formats and work internally with the meta container format.

\begin{figure}[h]
  \centering
      \includegraphics[width=0.6\textwidth]{AFImage_CD}
  \caption{AFImage class diagram.}
  \label{fig:AFImage_CD}
\end{figure}

The meta container AFImage contains a map of attributes (see Figure \ref{fig:AFImage_CD}) which can be used by algorithms to get information created by other algorithms or to store information into an existing image.

To interact with the user interface there is also a map of layers which contains shapes that are printed onto the image. The software uses this for example for recognised doors or rooms which are shown as overlay.

\subsection{Input \& Output}
The following sections gives a brief overview about the different input and output formats used by the software.

\subsubsection{DWG / DXF}
As requested by the client, the software should support the import and export of DWG and DXF formats. These file formats are standard in the architectural environment and can be imported and exported by the software AutoCAD of the company Autodesk.

There are several libraries for Java which support reading and writing of DWG and DXF files, but a lot of them are not maintained anymore or cost something. The table \ref{tbl:DWGEvaluationResult} shows the evaluated libraries together with the reason, why they are not suitable for this software (Please consult table \ref{tbl:DWGEvaluationMatrix} in the appendix for an extended comparison).

\begin{table}[h]
\centering
\caption{DWG / DXF Evaluation Result}
\label{tbl:DWGEvaluationResult}
\begin{tabular}{@{}lll@{}}
\toprule
Name         & Vendor         & Reason                                               \\ \midrule
YCAD Library & Ed Karlo       & No documentation and very unintuitive.                \\
Teigha       & ODA            & Too expensive and only for conversion.               \\
Kabeja       & -              & Could not read the example document.                 \\
Tika         & Apache         & Only a meta text reader.                             \\
jnetcad      & Johannes Raida & Only a converter.                                    \\
CaffViewer   & DeCaff         & Too expensive but able to read the example document. \\ \bottomrule
\end{tabular}
\end{table}

The only library which could read the test document provided by the client is the CaffViewer. But it is licensed under a closed source license and costs about 1350 Euro.

\subsubsection{Raster Graphics}



\subsubsection{Scalable Vector Graphics}
Because DWG and DXF support could not be implemented, rooms and other shapes which the software recognises can be exported to \gls{acro:SVG}.

In contrast to the raster image format, the \gls{acro:SVG} file contains commands to draw the image later. This is useful to resize an image without loss of quality and it is possible to select every single element of image.

With \gls{acro:SVG} it is possible to create an overlay for an existing plan.

\subsubsection{Comma-separated Values}

\subsection{Algorithm}
\todo{rewrite, this is nonsense}
\todo{Explain why it is of importance that algorithms can be used in a pipeline and in different orders, why it is essential that we can swap them out, reuse them etx.}
To reuse algorithms in different workflows, the software architecture splits the algorithms into small parts which then can be connected together to pipelines. The algorithm itself does not know in which context it is running. As input parameter it gets just an AFImage from the last algorithm output and is able to return an AFImage again (see Figure \ref{fig:IAlgorithm_CD}). 

\begin{figure}[h]
  \centering
      \includegraphics[width=0.6\textwidth]{IAlgorithm_CD}
  \caption{Algorithm interface class diagram.}
  \label{fig:IAlgorithm_CD}
\end{figure}

\subsubsection{Parameter}
Because a lot of the algorithms need parameters to be set manually, there is the possibility to flag these parameters with an attribute in the code and the software is then able to automatically show a slider in the user interface. With this slider the user is able to set the parameter or use the default values (See Figure \ref{fig:parameter_window}).


\begin{figure}[h]
  \centering
      \includegraphics[width=0.6\textwidth]{parameter_window}
  \caption{Flag based parameter window.}
  \label{fig:parameter_window}
\end{figure}

\subsubsection{History}
As seen in Figure \ref{fig:IAlgorithm_CD} and Figure \ref{fig:parameter_window}, an algorithm is not just able to return one AFImage, instead it can return an unlimited count of AFImages, which then are displayed in the parameter window. These images are used to show a history of the steps the algorithm performed. This makes it easier to set the right parameter for the given algorithm and helps to debug all steps of an algorithm.

\subsection{Workflow}


\begin{figure}[h]
  \centering
      \includegraphics[width=1\textwidth]{workflow}
  \caption{Workflow example with two algorithms.}
  \label{fig:Workflow}
\end{figure}

\subsection{User Interface}
\missingfigure{User Interface Image.}
\todo{Why it looks like that. (Andere Software)}